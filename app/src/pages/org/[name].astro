---
import Layout from "../../layouts/Layout.astro";
import FreshnessBadge from "../../components/FreshnessBadge.astro";
import { loadSnapshot, getOrganizationBySlug, getDatasets } from "../../lib/snapshot";

export function getStaticPaths() {
  const snapshot = loadSnapshot();
  return snapshot.organizations.map((org) => ({
    params: { name: org.name },
  }));
}

const orgName = Astro.params.name ?? "";
const snapshot = loadSnapshot();
const org = getOrganizationBySlug(snapshot, orgName);
if (!org) {
  return Astro.redirect(import.meta.env.BASE_URL);
}

const allDatasets = getDatasets(snapshot);
const orgDatasets = [...allDatasets]
  .filter((d) => d.organization.name === orgName)
  .sort((a, b) => a.days_since_modified - b.days_since_modified);
const base = import.meta.env.BASE_URL;
---
<Layout title={`${org.title} — Observatorio`} description={`Datasets de ${org.title}.`}>
  <h1>{org.title}</h1>
  <p class="org-slug">{org.name}</p>

  <section class="cards">
    <div class="card">
      <div class="value">{org.datasets_total}</div>
      <div class="label">Datasets</div>
    </div>
    <div class="card">
      <div class="value">{org.datasets_green}</div>
      <div class="label">Verde</div>
    </div>
    <div class="card">
      <div class="value">{org.datasets_yellow}</div>
      <div class="label">Amarillo</div>
    </div>
    <div class="card">
      <div class="value">{org.datasets_red}</div>
      <div class="label">Rojo</div>
    </div>
    <div class="card">
      <div class="value">{org.resources_broken}</div>
      <div class="label">Recursos rotos</div>
    </div>
    <div class="card">
      <div class="value">{org.resources_parse_failed}</div>
      <div class="label">Parse fallido</div>
    </div>
  </section>

  <h2>Datasets</h2>
  <label for="dataset-search" class="visually-hidden">Buscar por título o nombre</label>
  <input
    type="search"
    id="dataset-search"
    placeholder="Filtrar por título o nombre..."
    autocomplete="off"
  />
  <div class="table-wrap">
    <table class="dataset-table sortable-table" data-default-key="days_since_modified" data-default-dir="asc">
      <thead>
        <tr>
          <th data-sort-key="title" data-sort-type="string">Título</th>
          <th data-sort-key="freshness_order" data-sort-type="number">Freshness</th>
          <th data-sort-key="days_since_modified" data-sort-type="number">Días desde mod.</th>
          <th data-sort-key="resources_total" data-sort-type="number">Recursos</th>
          <th data-sort-key="resources_broken" data-sort-type="number">Rotos</th>
          <th data-sort-key="resources_parse_failed" data-sort-type="number">Parse fallido</th>
          <th data-sort-key="formats" data-sort-type="string">Formatos</th>
        </tr>
      </thead>
      <tbody>
        {orgDatasets.map((d) => (
          <tr
            data-title={d.title.toLowerCase()}
            data-name={d.name.toLowerCase()}
            data-days_since_modified={d.days_since_modified}
            data-freshness_order={{ green: 0, yellow: 1, red: 2, unknown: 3 }[d.freshness_bucket]}
            data-resources_total={d.resources_total}
            data-resources_broken={d.resources_broken}
            data-resources_parse_failed={d.resources_parse_failed}
            data-formats={d.formats.join(", ").toLowerCase()}
          >
            <td>
              <a href={`${base}dataset/${d.name}`}>{d.title}</a>
            </td>
            <td><FreshnessBadge bucket={d.freshness_bucket} /></td>
            <td>{d.days_since_modified}</td>
            <td>{d.resources_total}</td>
            <td>{d.resources_broken}</td>
            <td>{d.resources_parse_failed}</td>
            <td>{d.formats.join(", ")}</td>
          </tr>
        ))}
      </tbody>
    </table>
  </div>
  <nav class="pagination" aria-label="Paginación de datasets">
    <p class="pagination-summary" id="pagination-summary">—</p>
    <div class="pagination-buttons">
      <button type="button" class="pagination-prev" id="pagination-prev" aria-label="Página anterior">Anterior</button>
      <button type="button" class="pagination-next" id="pagination-next" aria-label="Página siguiente">Siguiente</button>
    </div>
  </nav>
</Layout>

<script>
  const PAGE_SIZE = 15;

  const input = document.getElementById("dataset-search") as HTMLInputElement;
  const tbody = document.querySelector(".dataset-table tbody");
  const summaryEl = document.getElementById("pagination-summary");
  const prevBtn = document.getElementById("pagination-prev");
  const nextBtn = document.getElementById("pagination-next");

  let currentPage = 1;

  function getMatchingRows(): HTMLTableRowElement[] {
    if (!tbody) return [];
    const q = (input?.value ?? "").trim().toLowerCase();
    const rows = Array.from(tbody.querySelectorAll<HTMLTableRowElement>("tr"));
    if (!q) return rows;
    return rows.filter((row) => {
      const title = (row.getAttribute("data-title") ?? "").trim();
      const name = (row.getAttribute("data-name") ?? "").trim();
      return title.includes(q) || name.includes(q);
    });
  }

  function applyPage() {
    if (!tbody || !summaryEl) return;
    const matching = getMatchingRows();
    const total = matching.length;
    const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
    currentPage = Math.max(1, Math.min(currentPage, totalPages));
    const start = (currentPage - 1) * PAGE_SIZE;
    const end = Math.min(start + PAGE_SIZE, total);

    matching.forEach((row, i) => {
      (row as HTMLElement).style.display = i >= start && i < end ? "" : "none";
    });

    if (total === 0) {
      summaryEl.textContent = "Ningún dataset coincide con el filtro.";
    } else {
      summaryEl.textContent = `Mostrando ${start + 1}-${end} de ${total} dataset${total !== 1 ? "s" : ""}.`;
    }

    if (prevBtn) {
      if (currentPage <= 1) prevBtn.setAttribute("disabled", "");
      else prevBtn.removeAttribute("disabled");
    }
    if (nextBtn) {
      if (currentPage >= totalPages) nextBtn.setAttribute("disabled", "");
      else nextBtn.removeAttribute("disabled");
    }
  }

  if (input) {
    input.addEventListener("input", () => {
      currentPage = 1;
      applyPage();
    });
  }
  if (prevBtn) {
    prevBtn.addEventListener("click", () => {
      if (currentPage > 1) {
        currentPage--;
        applyPage();
      }
    });
  }
  if (nextBtn) {
    nextBtn.addEventListener("click", () => {
      const matching = getMatchingRows();
      const totalPages = Math.max(1, Math.ceil(matching.length / PAGE_SIZE));
      if (currentPage < totalPages) {
        currentPage++;
        applyPage();
      }
    });
  }

  function initSortable(table: HTMLTableElement, onAfterSort?: () => void) {
    const tbodyEl = table.querySelector("tbody");
    const headers = table.querySelectorAll<HTMLTableCellElement>("thead th[data-sort-key]");
    if (!tbodyEl || !headers.length) return;

    const defaultKey = table.dataset.defaultKey ?? "";
    const defaultDir = (table.dataset.defaultDir ?? "asc") as "asc" | "desc";
    let currentKey = defaultKey;
    let currentDir = defaultDir;

    function sort() {
      const rows = Array.from(tbodyEl.querySelectorAll("tr"));
      const key = currentKey;
      const dir = currentDir;
      const type = table.querySelector(`th[data-sort-key="${key}"]`)?.getAttribute("data-sort-type") ?? "string";

      rows.sort((a, b) => {
        const rawA = a.getAttribute(`data-${key}`);
        const rawB = b.getAttribute(`data-${key}`);
        let cmp = 0;
        if (type === "number") {
          const numA = Number(rawA) ?? 0;
          const numB = Number(rawB) ?? 0;
          cmp = numA - numB;
        } else {
          cmp = String(rawA ?? "").localeCompare(String(rawB ?? ""));
        }
        return dir === "asc" ? cmp : -cmp;
      });

      rows.forEach((r) => tbodyEl.appendChild(r));
      onAfterSort?.();
    }

    function setIndicator(key: string) {
      headers.forEach((h) => {
        h.classList.remove("sort-asc", "sort-desc");
        h.removeAttribute("aria-sort");
      });
      const thActive = table.querySelector(`th[data-sort-key="${key}"]`) as HTMLTableCellElement;
      if (thActive) {
        thActive.classList.add(currentDir === "asc" ? "sort-asc" : "sort-desc");
        thActive.setAttribute("aria-sort", currentDir === "asc" ? "ascending" : "descending");
      }
    }

    headers.forEach((th) => {
      th.setAttribute("tabindex", "0");
      th.setAttribute("role", "button");
      th.addEventListener("click", () => {
        const key = th.getAttribute("data-sort-key") ?? "";
        if (key === currentKey) currentDir = currentDir === "asc" ? "desc" : "asc";
        else {
          currentKey = key;
          currentDir = (th.getAttribute("data-sort-type") === "number" ? "asc" : "asc") as "asc" | "desc";
        }
        setIndicator(currentKey);
        sort();
      });
      th.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          th.click();
        }
      });
    });

    setIndicator(currentKey);
    sort();
  }
  document.querySelectorAll<HTMLTableElement>(".sortable-table").forEach((t) => initSortable(t, applyPage));
</script>

<style>
  .org-slug { color: #6c757d; font-size: 0.9rem; margin-top: -0.5rem; margin-bottom: 1.5rem; }
  h2 { margin-top: 2rem; }
  .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  .table-wrap { overflow-x: auto; }
  .pagination { margin-top: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 1rem; }
  .pagination-summary { margin: 0; font-size: 0.9rem; color: #495057; }
  .pagination-buttons { display: flex; gap: 0.5rem; }
  .pagination-prev, .pagination-next { padding: 0.4rem 0.75rem; font-size: 0.9rem; cursor: pointer; border: 1px solid #ced4da; border-radius: 4px; background: #fff; }
  .pagination-prev:hover:not(:disabled), .pagination-next:hover:not(:disabled) { background: #e9ecef; }
  .pagination-prev:disabled, .pagination-next:disabled { opacity: 0.6; cursor: not-allowed; }
</style>
